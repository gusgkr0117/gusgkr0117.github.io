I"s<p>Montgomery Multiplication은 모듈러 곱을 효율적으로 수행하는 알고리즘이다.</p>

<h3 id="모듈러-곱을-빠르게-수행하려면-어떻게-해야할까">모듈러 곱을 빠르게 수행하려면 어떻게 해야할까?</h3>

<p>소수 $p$가 주어졌을 때, Modular Multiplication은 $a$와 $b$로부터 $a \cdot b \mod p$를 구하는 것을 말한다.
단순한 방법으로 $a \cdot b$를 수행하고 이 값이 $p$보다 작아질 때까지 $p$를 빼주면 된다.
조금 더 개선한 방법으로는 $0 \leq a \cdot b - k \cdot p &lt; p$를 만족하는 k를 $[0,p^2)$ 구간에서 binary search 해주는 방법이 있겠다. 이는 대략 $O(2\log p)$의 시간복잡도를 가진다.</p>

<p>Modular 곱셈에서는 modular $p$를 해주는 연산이 가장 오래걸린다. modular 연산에 걸리는 시간을 효율적으로 줄이는게 Modular Multiplication 연산을 빠르게 수행할 수 있는 방법이다.</p>

<p>그런데 이진수를 사용한다면, $p = 2^k$꼴인 $p$에 대해서는 modular 연산이 k개의 least significant bit를 남기고 지우는 행위와 같다는 것을 알 수 있다. 이는 AND 논리 연산으로 아주 간단히 구현할 수 있다. $p \&amp; (2^k-1)$을 연산하면 되기 때문이다. 이러한 점에서 착안해 modular $p$연산을 modular $2^k$연산으로 변환하여 연산을 빠르게 수행하려는 것이 Montgomery Multiplication의 철학이다.</p>

<h3 id="montgomery-reduction">Montgomery reduction</h3>

<p>$a \cdot b$의 값을 $[0,p-1]$사이로 shift 연산만을 이용해 reduction 시킬 수 있는 경우가 존재할까?</p>

:ET